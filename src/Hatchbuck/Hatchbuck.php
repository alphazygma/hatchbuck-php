<?php /** @copyright Alejandro Salazar (c) 2017 */
namespace Hatchbuck;

/**
 * The <kbd>Hatchbuck</kbd> class is the main API interface.
 *
 * @author Alejandro Salazar (alphazygma@gmail.com)
 * @version 1.0
 * @package Hatchbuck
 */
class Hatchbuck
{
    const VERSION = 'v1';
    
    /** @var string */
    private static $API_KEY = null;
    /** @var \Hatchbuck\Auth\Auth */
    private static $AUTH = null;
    
    public static function setApiKey($apiKey, \Hatchbuck\Auth\Auth $auth)
    {
        static::$API_KEY = $apiKey;
        static::$AUTH    = $auth;
    }
    
    /**
     * Get a list of Contacts for the supplied search input.
     * 
     * @param \Hatchbuck\SearchInput $searchInput
     * @return \Hatchbuck\Entity\Contact[]
     * @throws \Hatchbuck\Exception\InvalidSearchException
     */
    public function search(SearchInput $searchInput)
    {
        if (!$searchInput->isValidSearch()) {
            throw new \Hatchbuck\Exception\InvalidSearchException();
        }
        
        $api = 'contact/search';
        
        $searchArray = [];
        hb_array_set($searchArray, 'contactId', $searchInput->getContactId());
        hb_array_set($searchArray, 'firstName', $searchInput->getFirstName());
        hb_array_set($searchArray, 'lastName', $searchInput->getLastName());
        hb_array_set($searchArray, 'emails', $searchInput->getEmailList());
        
        $reqClient    = $this->_getRequestClient();
        $responseList = $reqClient->post($api, $searchArray);

        // In-place replacement of the Array Map representation with the Contact Object representation.
        $contactList = hb_to_entity_list($responseList, \Hatchbuck\Entity\Contact::class);
        
        return $contactList;
    }
    
    /**
     * Adds a new contact into the system and returns a new parsed version of the contact with all
     * the respective IDs generated by the CRM.
     * @param \Hatchbuck\Entity\Contact $contact
     * @return \Hatchbuck\Entity\Contact The inserted contact with respective IDs
     * @throws \Hatchbuck\Exception\User\ExistingContactException
     * @throws \Hatchbuck\Exception\User\InvalidNewContactException
     */
    public function addContact(\Hatchbuck\Entity\Contact $contact)
    {
        if ($contact->getContactId() != null) {
            throw new \Hatchbuck\Exception\User\ExistingContactException($contact);
        }
        
        if (empty($contact->getEmailList()) || empty($contact->getStatus())) {
            throw new Exception\User\InvalidNewContactException();
        }
        
        $api = 'contact';
        
        $dataArray = $contact->toArray();
        
        $reqClient = $this->_getRequestClient();
        $response  = $reqClient->post($api, $dataArray);
        
        $newContact = hb_to_entity($response, \Hatchbuck\Entity\Contact::class);
        
        return $newContact;
    }
    
    public function addTag(\Hatchbuck\Entity\Contact $contact, \Hatchbuck\Entity\Tag $tag)
    {
        if (empty($contact->getContactId())) {
            throw new \Hatchbuck\Exception\MissingIdException();
        }
        
        $api = 'contact/' . $contact->getContactId() . '/tags';
        
        $dataArray = [$tag->toArray()];
        
        $reqClient = $this->_getRequestClient();
        $reqClient->post($api, $dataArray);
    }
    
    /**
     * Returns an Http Request client to perform calls to the Hatchbuck API.
     * @return \Hatchbuck\Http\Request
     */
    protected function _getRequestClient()
    {
        // Declaring this class variable locally as I am not looking forward for this variable to
        // be used directly without going through this method to avoid other calls forgetting to
        // initialize it or modifying the value accidentally.
        // This also allows for some sort of caching of the Request object as well as mocking for tests.
        if (!isset($this->_requestClient)) {
            $this->_requestClient = new \Hatchbuck\Http\Request(
                static::$API_KEY, static::$AUTH
            );
        }
        
        return $this->_requestClient;
    }
}
